//! Tests for RTTI (Runtime Type Information) system

use cppvtable::rtti::{TypeInfo, InterfaceInfo, VTableWithRtti, get_type_info};
use std::ffi::c_void;

// Define interface IDs using static addresses
static IID_ISWIMMER: u8 = 0;
static IID_IFLYER: u8 = 0;

fn iid_swimmer() -> usize {
    &IID_ISWIMMER as *const u8 as usize
}

fn iid_flyer() -> usize {
    &IID_IFLYER as *const u8 as usize
}

// Manual vtable struct (normally generated by proc-macro)
#[repr(C)]
struct ISwimmerVTable {
    swim: extern "C" fn(*mut c_void),
}

#[repr(C)]
struct IFlyerVTable {
    fly: extern "C" fn(*mut c_void),
}

// Duck implements both interfaces
#[repr(C)]
struct Duck {
    vtable_swimmer: *const ISwimmerVTable,
    vtable_flyer: *const IFlyerVTable,
    name: [u8; 8],
}

// Implementation functions
extern "C" fn duck_swim(_this: *mut c_void) {
    println!("Duck swimming!");
}

extern "C" fn duck_fly(_this: *mut c_void) {
    println!("Duck flying!");
}

// TypeInfo for Duck
static DUCK_INTERFACES: [InterfaceInfo; 2] = [
    InterfaceInfo {
        interface_id: 0, // Will be set at runtime via test
        offset: 0,       // ISwimmer at offset 0
    },
    InterfaceInfo {
        interface_id: 0, // Will be set at runtime via test  
        offset: 8,       // IFlyer at offset 8 (size of pointer)
    },
];

// We need a mutable version for testing since interface_id depends on static addresses
static DUCK_TYPE_INFO: TypeInfo = TypeInfo {
    type_id: 0x12345678,
    type_name: "Duck",
    interfaces: &[],  // Empty for now, we'll test with a local version
};

// VTable with RTTI
static DUCK_SWIMMER_VTABLE_INNER: ISwimmerVTable = ISwimmerVTable { swim: duck_swim };
static DUCK_FLYER_VTABLE_INNER: IFlyerVTable = IFlyerVTable { fly: duck_fly };

#[test]
fn test_type_info_creation() {
    let interfaces = [
        InterfaceInfo {
            interface_id: iid_swimmer(),
            offset: 0,
        },
        InterfaceInfo {
            interface_id: iid_flyer(),
            offset: 8,
        },
    ];
    
    let type_info = TypeInfo::new(0x12345678, "Duck", &[]);
    
    assert_eq!(type_info.type_id, 0x12345678);
    assert_eq!(type_info.type_name, "Duck");
}

#[test]
fn test_interface_info_size() {
    // InterfaceInfo should be 2 * pointer size
    let size = std::mem::size_of::<InterfaceInfo>();
    #[cfg(target_pointer_width = "64")]
    assert_eq!(size, 16);
    #[cfg(target_pointer_width = "32")]
    assert_eq!(size, 8);
}

#[test]
fn test_type_info_implements() {
    let interfaces: &'static [InterfaceInfo] = &[
        InterfaceInfo {
            interface_id: 100,
            offset: 0,
        },
        InterfaceInfo {
            interface_id: 200,
            offset: 8,
        },
    ];
    
    // Leak to get 'static lifetime for test
    let interfaces: &'static [InterfaceInfo] = Box::leak(Box::new([
        InterfaceInfo { interface_id: 100, offset: 0 },
        InterfaceInfo { interface_id: 200, offset: 8 },
    ]));
    
    let type_info = TypeInfo::new(1, "TestType", interfaces);
    
    assert!(type_info.implements(100));
    assert!(type_info.implements(200));
    assert!(!type_info.implements(300));
}

#[test]
fn test_query_interface() {
    let interfaces: &'static [InterfaceInfo] = Box::leak(Box::new([
        InterfaceInfo { interface_id: 100, offset: 0 },
        InterfaceInfo { interface_id: 200, offset: 8 },
    ]));
    
    let type_info = TypeInfo::new(1, "TestType", interfaces);
    
    // Create a dummy object
    let dummy = [0u8; 32];
    let object_ptr = dummy.as_ptr() as *const c_void;
    
    unsafe {
        // Query for interface at offset 0
        let ptr1 = type_info.query_interface(object_ptr, 100);
        assert_eq!(ptr1, object_ptr);
        
        // Query for interface at offset 8
        let ptr2 = type_info.query_interface(object_ptr, 200);
        assert_eq!(ptr2, (object_ptr as *const u8).offset(8) as *const c_void);
        
        // Query for non-existent interface
        let ptr3 = type_info.query_interface(object_ptr, 999);
        assert!(ptr3.is_null());
    }
}

